多态（Polymorphism）是面向对象语言的一种特征，让您能够以相似的方式处理不同类型的对象。

## 1. 使用虚函数实现多态
看一下如下例程：
```cpp
#include <iostream>
using namespace std;

class Fish
{
public:
   /* virtual */ void Swim() { cout << "Fish swims!" << endl; }
};

class Tuna : public Fish
{
public:
   void Swim() { cout << "Tuna swims!" << endl; }
};

class Carp:public Fish
{
public:
   void Swim() { cout << "Carp swims!" << endl; }
};

int main() 
{
   // 引用形式
   Fish myFish;
   Tuna myTuna;
   Carp myCarp;
   Fish &rFish1 = myFish;
   Fish &rFish2 = myTuna;
   Fish &rFish3 = myCarp;
   rFish1.Swim();
   rFish2.Swim();
   rFish3.Swim();

   // 指针形式
   Fish *pFish1 = new Fish();
   Fish *pFish2 = new Tuna();
   Fish *pFish3 = new Carp();
   pFish1->Swim();
   pFish2->Swim();
   pFish3->Swim();

   return 0;
}
```
直接编译运行代码，得到如下结果：
```
Fish swims!
Fish swims!
Fish swims!
Fish swims!
Fish swims!
Fish swims!
```
将第 7 行的 virtual 关键字取消注释，再将编译运行代码，得到如下结果：
```
Fish swims!
Tuna swims!
Carp swims!
Fish swims!
Tuna swims!
Carp swims!
```

分析上述例程：
1. 派生类对象可以赋值给基类对象(这里对象是广义称法，代指对象、指针、引用)，例程中使用基类引用或指针指向派生类对象
2. 如果基类中的 Swim() 不是虚函数，那么基类引用(或指针)指向何种类型的对象，运行时都调用基类中的方法。这种情况未启用多态机制
3. 如果基类中的 Swim() 是虚函数，那么运行时会根据基类引用(或指针)指向的具体对象，调用对应类中的方法。若指向派生类对象则调用派生类方法，若指向基类对象则调用基类中的方法。这种情况使用了多态机制。

使用基类指针或引用指向基类或派生类对象，运行时调用所指向对象对应的类(具有继承层次关系的基类或派生类)中的方法，这就是多态。在编写代码时，将派生类对象视为基类对象进行统一处理，程序运行时调用对象所属的派生类方法。

编程实践：**对于将被派生类覆盖的基类方法，务必将其声明为虚函数**，以使其支持多态。

## 2. 虚析构函数
虚析构函数与普通虚函数机制并无不同。

如果不将析构函数声明为虚函数，那么如果一个函数的形参是基类指针，实参是指向堆内存的派生类指针时，函数返回时作为实参的派生类指针将被当作基类指针进行析构，这会导致资源释放不完全和内存泄漏；要避免这一问题，可将基类的析构函数声明为虚函数，那么函数返回时，作为实参的派生类指针就会被当作派生类指针进行析构，这是正确的。

换句话说，对于使用 new 在堆内存中实例化的派生类对象，如果将其赋给基类指针，并通过基类指针调用 delete，如果基类析构函数不是虚函数，delete 将按基类析构的方式来析构此指针，如果基类析构函数是虚函数，delete 将按派生类析构的方式来析构此指针(调用派生类析构函数和基类析构函数)。

编程实践：**务必要将基类的析构函数声明为虚函数**，以避免派生类实例未被妥善销毁的情况发生。

## 3. 多态机制的工作原理-虚函数表
以第 1 节中 `Fish *pFish3 = new Carp();` 语句为例，在编译阶段，编译器并不知道传递给 pFish3 变量的是哪种类型的对象，无法确定执行哪个类中的 Swim( )方法。调用哪个 Swim() 方法显然是在运行阶段决定的，这是使用实现多态的逻辑完成的，而这种逻辑由编译器在编译阶段提供。

如下 Base 类声明了 N 个虚函数：
```cpp
class Base
{
public:
    virtual void Func1() { // Func1 implementation }
    virtual void Func2() { // Func2 implementation }
    // .. so on and so forth
    virtual void FuncN() { // FuncN implementation }
};
```

如下 Derived 类继承自 Base 类，并覆盖了除 Base::Func2() 外的其他所有虚函数。
```
class Derived: public Base
{
public:
    virtual void Func1() { // Func2 overrides Base::Func2() }
    // no implementation for Func2()
    // .. so on and so forth
    virtual void FuncN() { // FuncN overrides Base::FuncN() }
};
```

编译器见到这种继承层次结构后，知道 Base 定义了一些虚函数，并在 Derived 中覆盖了它们。在这种情况下，编译器将为实现了虚函数的基类和覆盖了虚函数的派生类分别创建一个虚函数表（Virtual Function Table, VFT)。换句话说，Base 和 Derived 类都将有自己的虚函数表。实例化这些类的对象时，会为每个对象创建一个隐藏的指针(我们称之为 VFT*)，它指向相应的 VFT。可将 VFT 视为一个包含函数指针的静态数组，其中每个指针都指向相应的虚函数，如下图所示。

![基类和派生类的虚函数表](https://leichn.github.io/img/cpp/VFTForClass.jpg "基类和派生类的虚函数表")  

每个虚函数表都由函数指针组成，其中每个指针都指向相应虚函数的实现。在类 Derived 的虚函数表中，除一个函数指针外，其他所有函数指针都指向 Derived 本地的虚函数实现。Derived 没有覆盖 Base::Func2()，因此相应的函数指针指向 Base 类的 Func2() 实现。

这意味着遇到下述代码时，编译器将查找 Derived 类的 VFT，最终调用的是 Base::Func2() 的实现：
```cpp
CDerived objDerived;
objDerived.Func2();
```

调用被覆盖的虚函数时，也是类似的机制：
```cpp
void DoSomething(Base& objBase)
{
    objBase.Func1(); // invoke Derived::Func1
}
int main()
{
    Derived objDerived;
    DoSomething(objDerived);
};
```

在这种情况下，虽然将 objDerived 传递给了 objBase，进而被解读为一个 Base 实例，但该实例的 VFT 指针仍指向 Derived 类的虚函数表，因此通过该 VTF 执行的是 Derived::Func1()。

C++ 就是通过虚函数表实现多态的。

```cpp
#include <iostream>
using namespace std;

class Class1
{
private:
   int a, b;

public:
   void DoSomething() {}
};

class Class2
{
private:
   int a, b;

public:
   virtual void DoSomething() {}
};

int main() 
{
   cout << "sizeof(Class1) = " << sizeof(Class1) << endl;
   cout << "sizeof(Class2) = " << sizeof(Class2) << endl;

   return 0;
}
```
在 64 位系统下编译并运行，结果为：
```
sizeof(Class1) = 8
sizeof(Class2) = 16
```
Class2 中将函数声明为虚函数，因此类的成员多了一个 VFT 指针，64 位系统中，指针变量占用 8 字节空间，因此 Class2 比 Class1 多占用了 8 个字节。

## 4. 纯虚函数和抽象基类
不能实例化的基类被称为抽象基类，这样的基类只有一个用途，那就是从它派生出其他类。在 C++ 中，要创建抽象基类，可声明纯虚函数。

抽象基类用于定义接口但不实现，在派生类中实现接口，抽象基类中的所有接口都必须在派生类中实现？这样可以实现接口与实现的分离。抽象基类提供了一种非常好的机制，让您能够声明所有派生类都必须实现的函数

纯虚函数写法如下：
```
class AbstractBase
{
public:
    virtual void DoSomething() = 0; // pure virtual method
};
```
其派生类中必须实现此函数。

## 5. 使用虚继承解决菱形问题
一个类继承多个父类，而这多个父类又继承同一个更高层次的父类时，会引发菱形问题。例如，鸭嘴兽具备哺乳动物、鸟类和爬行动物的特征，这意味着 Platypus 类需要继承 Mammal、 Bird 和 Reptile 三个类。然而，这些类都从同一个 Animal 类派生而来，如下图所示：

![多继承的菱形问题](https://leichn.github.io/img/cpp/DiamondProblem.jpg "多继承的菱形问题")  

例程如下：
```cpp
#include <iostream>
using namespace std;

class Animal
{
public:
	Animal() { cout << "Animal constructor" << endl; }

	int age;
};

class Mammal : public /* virtual */ Animal
{
};

class Bird : public /* virtual */ Animal
{
};

class Reptile : public /* virtual */ Animal
{
};

class Platypus : public Mammal, public Bird, public Reptile
{
public:
	Platypus() { cout << "Platypus constructor" << endl; }
};

int main()
{
	Platypus duckBilledP;

	// uncomment next line to see compile failure
	// age is ambiguous as there are three instances of base Animal 
	// duckBilledP.age = 25;

	duckBilledP.Mammal::age = 25;
	duckBilledP.Bird::age = 25;
	duckBilledP.Reptile::age = 25;

	return 0;
}
```
编译并运行，输出结果如下：
```
Animal constructor
Animal constructor
Animal constructor
Platypus constructor
```
可见，Platypus 有三个 Animal 实例。如果取消 235 行的注释，编译无法通过，因为无法确定是要设置哪个 Animal 实例中的 age 成员。

如果取消 Mammal、 Bird 和 Reptile 三个类声明处对关键字 virtual 的注释，再次编译运行，可看到如下输出结果：
```
Animal constructor
Platypus constructor
```
此时，Platypus 只有一个 Animal 实例。可见使用虚继承可以解决多继承时的菱形问题，确保

在继承层次结构中，继承多个从同一个类派生而来的基类时，如果这些基类没有采用虚继承，将导致二义性。这种二义性被称为菱形问题(Diamond Problem)。

C++关键字 virtual 被用于实现两个不同的概念，其含义随上下文而异，如下：
1. 在函数声明中， virtual 意味着当基类指针指向派生对象时，通过它可调用派生类的相应函数。
2. 从 Base 类派生出 Derived1 和 Derived2 类时，如果使用了关键字 virtual，则意味着再从 Derived1 和 Derived2 派生出 Derived3 时，每个 Derived3 实例只包含一个 Base 实例。

## 6. 使用 override 明确表明覆盖意图
从 C++11 起，程序员可使用限定符 override 来核实被覆盖的函数在基类中是否被声明为虚函数。形式如下：
```cpp
class Fish
{
public:
   virtual void Swim()
   {
      cout << "Fish swims!" << endl;
   }
};

class Tuna:public Fish
{
public:
   void Swim() const override // Error: no virtual fn with this sig in Fish
   {
      cout << "Tuna swims!" << endl;
   }
   void Swim() override       // Right: has virtual fn with this sig in Fish
   {
      cout << "Tuna swims!" << endl;
   }
};
```

换而言之， override 提供了一种强大的途径，让程序员能够明确地表达对基类的虚函数进行覆盖的意图，进而让编译器做如下检查：
• 基类函数是否是虚函数？
• 派生类中被声明为 override 的函数是否是基类中对应虚函数的覆盖？确保没有有手误写错。

编程实践：**在派生类中声明要覆盖基类函数的函数时，务必使用关键字 override**

## 7. 使用 final 禁止覆盖
被声明为 final 的类禁止继承，不能用作基类。而被声明为 final 的虚函数，不能在派生类中进行覆盖。

因此，要在 Tuna 类中禁止进一步定制虚函数 Swim()，可像下面这样做：
```cpp
class Tuna:public Fish
{
public:
   // override Fish::Swim and make this final
   void Swim() override final
   {
      cout << "Tuna swims!" << endl;
   }
};
```
Tuna 类可以被继承，但 Swim() 函数不能派生类中的实现覆盖。

## 8. 可将复制构造函数声明为虚函数吗
答案是不可以。不可能实现虚复制构造函数，因为在基类方法声明中使用关键字 virtual 时，表示它将被派生类的实现覆盖，这种多态行为是在运行阶段实现的。而构造函数只能创建固定类型的对象，不具备多态性，因此 C++不允许使用虚复制构造函数。

虽然如此，但存在一种不错的解决方案，就是定义自己的克隆函数来实现上述目的。这部分内容有些复杂，待用到时再作补充。